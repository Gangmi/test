package f_exception;

public class Ex01_tryCatch {

	public static void main(String[] args) {
		String[] msg = new String[] { "행복하자", "끝내자", "맛난거먹자" };

		try { // 예외가 발생 할 수 있는 구문을 안에 쓰고

			for (int i = 0; i <= msg.length; i++) { // i가 2라면 행복하자 끝내자가 나올 것이다. //그게 아니고 4를 준다면 index 3번째가 없기 때문에 에러가
													// 나온다.
				System.out.println(msg[i]); // 그리고 이 경우에 for 반복문 안에서 에러가 났기 때문에 프로그램이 멈추게 된다. -> 큰 일이다. 예외가 발생할 경우로 설정
				
			}
			return; //만약 예외가 발생하지 않을 경우에 여기서 return을 통해서 제어권을 넘겼어도 아래에 finally 안에 있는 구문은 무조건 실행하고 반환하게 된다.
					//만약 예외가 발생한다면 그순간에 *(for안에서 바로 catch 로 넘어가기 때문에 return이 실행이 안 된다).
					//바로 catch로 넘어가기 때문에 그 아래에 있는 모든 구문이 실행된다.
					//main에서 return을 사용하면 제어권이 jvm으로 넘어가기 때문에 프로그램이 종료된다.
			
			
		} catch (Exception ex) {// 예외가 발생 하면 이 catch가 잡아낸다. 무슨예외가 발생했는지 본다던가,그런거
			System.out.println("예외처리: " + ex.toString());
		}finally{//finally의 경우엔 예외가 발생 하든 아니든 실행 할 코드
			
			
			System.out.println("무조건 실행 구문"); //finally가 있는것과 없는것이 무슨 차이가 있을까? 무조건이 뭐에 포함이 되는가?  위에 return참조
			
		}//그리고 나서 실행 할 구문
			System.out.println("프로그램 정상 종료");
			//어쨌든 프로그램을 무조건 구동 시키고 싶을 때 이런식의 try catch를 사용하는 경우가 많다. -> 외부로 프로그램을 돌렸을 때 이 프로그램의 문제가 아니라
			//외부적인 문제로도 에러가 발생 할 수 있기 때문에 이런 예외를 관리하는 것은 필수다.
	}

}
/*
 * 	오류
 * 		-에러: 심각한 오류 -> 대표적으로 compile오류  ->  print1n 이라고 쓸 경우에 프로그램 구동이 안되기 때문에 큰일.
 * 		-예외: 심각하지 않은 오류를 예외라고 한다. -> 예외를 처리하는것을 예외 처리라고 한다.
 * 			-> 개발자는 예외가 발생할것을 대비해서 예외 처리를 해야한다. 어쨌든 프로그램을 정상 종료 시키기 위해서 -> 갑자기 프로그램이 멈추는것을 방지하기 위해서
 * 
 * 		-예외 처리를 하는 방법
 * 			1)try ~ catch 구문 - > 예외를 잡는다.
 * 			try{
 * 				예외가 발생할 구문
 * 			} catch(Exception ex){
 * 				예외가 발생한 후의 구문
 * 			}finally{
 * 				예외관계 없이 무조건 실행하는 구문
 * 			}	
 * 
 * 			2) 메소드 뒤에 throws -> 예외를 던진다.
 * 			예를 들면 본사데이터 베이스에서 정보를 가져 올 때 db에서 문제가 있어서 정보가 넘어오지 못 할 경우 try catch를 하게되면 
 * 			다 정상으로 처리 되기 때문에 정보는 넘어오지 않고 아무것도 되지 않는 경우가 생기게된다.
 * 
 * 
 */
